const express = require('express');
const axios = require('axios');
const ffmpeg = require('fluent-ffmpeg');
const fs = require('fs');
const path = require('path');
const cors = require('cors');

const app = express();
const PORT = process.env.PORT || 3000;

// Configuration
const API_KEY = process.env.API_KEY || 'pk_video_converter_4k_2024';
const DOMAIN = process.env.RAILWAY_STATIC_URL || `http://localhost:${PORT}`;

// Middleware
app.use(cors());
app.use(express.json());

// Cr√©er les dossiers n√©cessaires
const UPLOAD_DIR = 'temp';
const OUTPUT_DIR = 'converted';
[UPLOAD_DIR, OUTPUT_DIR].forEach(dir => {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
});

// Middleware d'authentification simple
const authenticate = (req, res, next) => {
    const apiKey = req.headers['x-api-key'];
    if (apiKey !== API_KEY) {
        return res.status(403).json({ 
            error: 'Cl√© API invalide ou manquante',
            message: 'Ajoutez X-API-Key dans les headers'
        });
    }
    next();
};

// Fonction pour extraire l'ID Google Drive
function extractGoogleDriveId(url) {
    const patterns = [
        /\/file\/d\/([a-zA-Z0-9_-]+)/,
        /id=([a-zA-Z0-9_-]+)/,
        /\/open\?id=([a-zA-Z0-9_-]+)/,
        /drive\.google\.com\/.*[?&]id=([a-zA-Z0-9_-]+)/
    ];
    
    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match) return match[1];
    }
    return null;
}

// FONCTION ULTRA ROBUSTE pour t√©l√©charger depuis Google Drive
async function downloadFromGoogleDrive(url, outputPath) {
    const fileId = extractGoogleDriveId(url);
    if (!fileId) {
        throw new Error('ID Google Drive non trouv√© dans l\'URL');
    }
    
    console.log(`\nüì• T√©l√©chargement Google Drive: ${fileId}`);
    console.log(`üìÅ Destination: ${outputPath}`);
    
    // Strat√©gie de t√©l√©chargement en plusieurs √©tapes
    const strategies = [
        {
            name: 'M√©thode 1: Direct avec confirmation',
            url: `https://drive.google.com/uc?export=download&confirm=t&id=${fileId}`
        },
        {
            name: 'M√©thode 2: API alternative',
            url: `https://drive.google.com/uc?id=${fileId}&export=download&confirm=t`
        },
        {
            name: 'M√©thode 3: Avec token dynamique',
            url: `https://drive.google.com/uc?export=download&id=${fileId}`,
            requiresToken: true
        }
    ];
    
    let lastError = null;
    
    for (const strategy of strategies) {
        console.log(`\nüîÑ Essai: ${strategy.name}`);
        
        try {
            if (strategy.requiresToken) {
                // M√©thode complexe pour obtenir le token de confirmation
                await downloadWithConfirmationToken(fileId, outputPath);
            } else {
                // M√©thode directe
                await downloadDirect(strategy.url, outputPath);
            }
            
            // V√©rifier que le t√©l√©chargement est valide
            const stats = fs.statSync(outputPath);
            console.log(`‚úÖ Fichier t√©l√©charg√©: ${(stats.size / 1024 / 1024).toFixed(2)} MB`);
            
            // V√©rifier que ce n'est pas une page HTML
            if (stats.size < 50000) { // < 50KB, probablement HTML
                const content = fs.readFileSync(outputPath, 'utf8').substring(0, 200);
                if (content.includes('<!DOCTYPE') || content.includes('<html')) {
                    console.log('‚ö†Ô∏è Fichier HTML d√©tect√©, passage √† la strat√©gie suivante');
                    fs.unlinkSync(outputPath);
                    lastError = new Error('Page HTML re√ßue au lieu du fichier');
                    continue;
                }
            }
            
            // Succ√®s !
            return;
            
        } catch (error) {
            console.error(`‚ùå √âchec: ${error.message}`);
            lastError = error;
            
            // Nettoyer si le fichier existe
            if (fs.existsSync(outputPath)) {
                fs.unlinkSync(outputPath);
            }
        }
    }
    
    // Si toutes les strat√©gies ont √©chou√©
    throw new Error(`Impossible de t√©l√©charger le fichier Google Drive. Dernier erreur: ${lastError?.message}`);
}

// T√©l√©chargement direct
async function downloadDirect(url, outputPath) {
    const response = await axios({
        method: 'GET',
        url: url,
        responseType: 'stream',
        timeout: 1200000, // 20 minutes pour les tr√®s gros fichiers
        maxContentLength: Infinity,
        maxBodyLength: Infinity,
        headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Accept': '*/*',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive'
        },
        // Suivre les redirections
        maxRedirects: 10
    });
    
    const writer = fs.createWriteStream(outputPath);
    
    // Afficher la progression
    const totalSize = parseInt(response.headers['content-length'] || '0');
    let downloadedSize = 0;
    
    response.data.on('data', (chunk) => {
        downloadedSize += chunk.length;
        if (totalSize > 0) {
            const progress = (downloadedSize / totalSize * 100).toFixed(1);
            process.stdout.write(`\rüìä T√©l√©chargement: ${progress}% (${(downloadedSize / 1024 / 1024).toFixed(1)}MB / ${(totalSize / 1024 / 1024).toFixed(1)}MB)`);
        }
    });
    
    response.data.pipe(writer);
    
    return new Promise((resolve, reject) => {
        writer.on('finish', () => {
            console.log('\n‚úÖ T√©l√©chargement termin√©');
            resolve();
        });
        writer.on('error', reject);
        response.data.on('error', reject);
    });
}

// T√©l√©chargement avec token de confirmation (pour gros fichiers)
async function downloadWithConfirmationToken(fileId, outputPath) {
    // √âtape 1: Obtenir la page avec le token
    console.log('üîë R√©cup√©ration du token de confirmation...');
    
    const initialUrl = `https://drive.google.com/uc?export=download&id=${fileId}`;
    const response = await axios({
        method: 'GET',
        url: initialUrl,
        headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
    });
    
    const html = response.data;
    
    // Chercher le token de confirmation
    const tokenMatch = html.match(/confirm=([a-zA-Z0-9_-]+)/);
    const uuidMatch = html.match(/uuid=([a-zA-Z0-9_-]+)/);
    
    if (!tokenMatch) {
        throw new Error('Token de confirmation non trouv√©');
    }
    
    const confirmToken = tokenMatch[1];
    const uuid = uuidMatch ? uuidMatch[1] : '';
    
    console.log('üîì Token trouv√©:', confirmToken);
    
    // √âtape 2: T√©l√©charger avec le token
    const downloadUrl = `https://drive.google.com/uc?export=download&confirm=${confirmToken}&id=${fileId}${uuid ? '&uuid=' + uuid : ''}`;
    
    // Conserver les cookies
    const cookies = response.headers['set-cookie'] || [];
    const cookieString = cookies.map(c => c.split(';')[0]).join('; ');
    
    await downloadDirect(downloadUrl, outputPath);
}

// Fonction pour convertir la vid√©o (optimis√©e pour les r√©seaux sociaux)
async function convertVideo(inputPath, outputPath, quality = '4k') {
    return new Promise((resolve, reject) => {
        console.log(`\nüé¨ Conversion en ${quality}...`);
        
        // Obtenir les infos de la vid√©o
        ffmpeg.ffprobe(inputPath, (err, metadata) => {
            if (err) {
                reject(err);
                return;
            }
            
            const duration = metadata.format.duration;
            console.log(`üìπ Dur√©e: ${Math.floor(duration / 60)}:${Math.floor(duration % 60)}`);
            
            // Param√®tres optimis√©s pour les r√©seaux sociaux
            let outputOptions = [
                '-c:v libx264',      // Codec vid√©o H.264 (compatible partout)
                '-preset medium',     // Balance qualit√©/vitesse
                '-crf 23',           // Qualit√© (plus bas = meilleure qualit√©)
                '-c:a aac',          // Codec audio AAC
                '-b:a 192k',         // Bitrate audio
                '-movflags +faststart', // Optimisation pour streaming
                '-pix_fmt yuv420p'   // Format de pixels compatible
            ];
            
            // R√©solution selon la qualit√© demand√©e
            switch(quality) {
                case '4k':
                    outputOptions.push('-vf scale=3840:2160:force_original_aspect_ratio=decrease,pad=3840:2160:(ow-iw)/2:(oh-ih)/2');
                    outputOptions.push('-b:v 35M'); // Bitrate pour 4K
                    break;
                case '1080p':
                    outputOptions.push('-vf scale=1920:1080:force_original_aspect_ratio=decrease,pad=1920:1080:(ow-iw)/2:(oh-ih)/2');
                    outputOptions.push('-b:v 8M');  // Bitrate pour 1080p
                    break;
                case '720p':
                    outputOptions.push('-vf scale=1280:720:force_original_aspect_ratio=decrease,pad=1280:720:(ow-iw)/2:(oh-ih)/2');
                    outputOptions.push('-b:v 5M');  // Bitrate pour 720p
                    break;
                default:
                    // Garder la qualit√© originale
                    outputOptions.push('-b:v 10M');
            }
            
            const ffmpegCommand = ffmpeg(inputPath)
                .outputOptions(outputOptions)
                .on('start', (commandLine) => {
                    console.log('üéØ Commande FFmpeg:', commandLine);
                })
                .on('progress', (progress) => {
                    if (progress.percent) {
                        process.stdout.write(`\rüìä Conversion: ${Math.round(progress.percent)}%`);
                    }
                })
                .on('end', () => {
                    console.log('\n‚úÖ Conversion termin√©e');
                    resolve();
                })
                .on('error', (err) => {
                    console.error('‚ùå Erreur conversion:', err);
                    reject(err);
                })
                .save(outputPath);
        });
    });
}

// Route principale de l'API
app.post('/api/convert', authenticate, async (req, res) => {
    console.log('\n=== NOUVELLE REQU√äTE DE CONVERSION ===');
    console.log('üìÖ Date:', new Date().toISOString());
    console.log('üì¶ Body:', JSON.stringify(req.body, null, 2));
    
    const { url, quality = '4k', filename } = req.body;
    
    // Validation
    if (!url) {
        return res.status(400).json({ 
            error: 'URL requise',
            message: 'Fournissez une URL Google Drive ou directe'
        });
    }
    
    // G√©n√©rer des noms de fichiers uniques
    const timestamp = Date.now();
    const tempFile = path.join(UPLOAD_DIR, `temp_${timestamp}.mp4`);
    const outputFilename = filename || `video_${timestamp}_${quality}.mp4`;
    const outputFile = path.join(OUTPUT_DIR, outputFilename);
    
    try {
        // 1. T√©l√©charger la vid√©o
        console.log('\nüöÄ √âtape 1: T√©l√©chargement');
        
        if (url.includes('drive.google.com')) {
            await downloadFromGoogleDrive(url, tempFile);
        } else {
            // Support des URLs directes
            console.log('üì• T√©l√©chargement direct depuis:', url);
            await downloadDirect(url, tempFile);
        }
        
        // 2. V√©rifier que le fichier existe et est valide
        if (!fs.existsSync(tempFile)) {
            throw new Error('√âchec du t√©l√©chargement');
        }
        
        const stats = fs.statSync(tempFile);
        console.log(`\nüìÅ Fichier t√©l√©charg√©: ${(stats.size / 1024 / 1024).toFixed(2)} MB`);
        
        // 3. Convertir la vid√©o
        console.log('\nüöÄ √âtape 2: Conversion');
        await convertVideo(tempFile, outputFile, quality);
        
        // 4. Nettoyer le fichier temporaire
        fs.unlinkSync(tempFile);
        console.log('üóëÔ∏è Fichier temporaire supprim√©');
        
        // 5. G√©n√©rer l'URL de t√©l√©chargement
        const downloadUrl = `${DOMAIN}/download/${outputFilename}`;
        
        // 6. Programmer la suppression apr√®s 10 minutes
        setTimeout(() => {
            if (fs.existsSync(outputFile)) {
                fs.unlinkSync(outputFile);
                console.log(`üóëÔ∏è Fichier converti supprim√©: ${outputFilename}`);
            }
        }, 600000); // 10 minutes
        
        // 7. R√©ponse avec toutes les infos
        const finalStats = fs.statSync(outputFile);
        
        console.log('\n‚úÖ CONVERSION R√âUSSIE !');
        console.log(`üì¶ Taille finale: ${(finalStats.size / 1024 / 1024).toFixed(2)} MB`);
        console.log(`üîó URL: ${downloadUrl}`);
        
        res.json({
            success: true,
            message: 'Conversion r√©ussie',
            data: {
                downloadUrl: downloadUrl,
                directUrl: downloadUrl,
                filename: outputFilename,
                quality: quality,
                size: finalStats.size,
                sizeMB: (finalStats.size / 1024 / 1024).toFixed(2),
                expiresIn: '10 minutes',
                format: 'mp4',
                optimizedFor: 'social_media'
            }
        });
        
    } catch (error) {
        console.error('\n‚ùå ERREUR GLOBALE:', error);
        
        // Nettoyer les fichiers en cas d'erreur
        [tempFile, outputFile].forEach(file => {
            if (fs.existsSync(file)) {
                fs.unlinkSync(file);
            }
        });
        
        res.status(500).json({ 
            error: 'Erreur lors de la conversion',
            message: error.message,
            details: process.env.NODE_ENV === 'development' ? error.stack : undefined
        });
    }
});

// Route pour t√©l√©charger les fichiers convertis
app.get('/download/:filename', (req, res) => {
    const filename = req.params.filename;
    const filepath = path.join(OUTPUT_DIR, filename);
    
    // S√©curit√© : emp√™cher l'acc√®s aux dossiers parents
    if (filename.includes('..')) {
        return res.status(403).json({ error: 'Acc√®s interdit' });
    }
    
    // V√©rifier que le fichier existe
    if (!fs.existsSync(filepath)) {
        return res.status(404).json({ 
            error: 'Fichier non trouv√©',
            message: 'Le fichier a peut-√™tre expir√©'
        });
    }
    
    // Envoyer le fichier
    res.download(filepath, filename, (err) => {
        if (err) {
            console.error('Erreur t√©l√©chargement:', err);
            res.status(500).json({ error: 'Erreur lors du t√©l√©chargement' });
        }
    });
});

// Route de statut
app.get('/api/status', (req, res) => {
    res.json({
        status: 'online',
        version: '3.0 ULTRA',
        features: [
            '‚úÖ Support des gros fichiers Google Drive (>100MB)',
            '‚úÖ Multiples strat√©gies de t√©l√©chargement',
            '‚úÖ Gestion automatique des tokens de confirmation',
            '‚úÖ Support des URLs directes',
            '‚úÖ Progression en temps r√©el',
            '‚úÖ Conversion 4K optimis√©e'
        ],
        api: {
            endpoint: '/api/convert',
            method: 'POST',
            headers: {
                'X-API-Key': 'Votre cl√© API',
                'Content-Type': 'application/json'
            },
            body: {
                url: 'URL Google Drive ou directe (requis)',
                quality: '4k, 1080p, 720p, original (optionnel, d√©faut: 4k)',
                filename: 'Nom personnalis√© (optionnel)'
            }
        },
        supportedQualities: ['4k', '1080p', '720p', 'original'],
        supportedSources: [
            'Google Drive (tous types de partage)',
            'URLs directes (HTTP/HTTPS)',
            'Fichiers jusqu\'√† 5GB'
        ]
    });
});

// Page d'accueil simple
app.get('/', (req, res) => {
    res.json({
        name: 'Video Converter API - ULTRA Edition',
        version: '3.0',
        status: 'Ready',
        message: 'API ultra robuste pour conversion vid√©o 4K',
        documentation: '/api/status',
        usage: 'POST /api/convert avec X-API-Key header'
    });
});

// Route de test (pour debug)
app.post('/api/test', authenticate, (req, res) => {
    console.log('Test re√ßu:', req.body);
    res.json({
        success: true,
        received: req.body,
        timestamp: new Date().toISOString()
    });
});

// Gestion des erreurs 404
app.use((req, res) => {
    res.status(404).json({ 
        error: 'Route non trouv√©e',
        availableRoutes: [
            'GET /',
            'GET /api/status',
            'POST /api/convert',
            'POST /api/test',
            'GET /download/:filename'
        ]
    });
});

// D√©marrer le serveur
app.listen(PORT, () => {
    console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë          üöÄ VIDEO CONVERTER API - ULTRA EDITION üöÄ          ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë üì° Port      : ${PORT}                                          ‚ïë
‚ïë üîó URL       : ${DOMAIN}${' '.repeat(45 - DOMAIN.length)}‚ïë
‚ïë üîë API Key   : ${API_KEY ? 'Configur√©e ‚úÖ' : 'Non configur√©e ‚ùå'}                             ‚ïë
‚ïë üìÅ Dossiers  : ${UPLOAD_DIR}/ et ${OUTPUT_DIR}/                             ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë üéØ Fonctionnalit√©s:                                        ‚ïë
‚ïë ‚Ä¢ Support des gros fichiers Google Drive (>100MB)          ‚ïë
‚ïë ‚Ä¢ Multiples strat√©gies de t√©l√©chargement                   ‚ïë
‚ïë ‚Ä¢ Conversion 4K avec optimisation r√©seaux sociaux          ‚ïë
‚ïë ‚Ä¢ Progression en temps r√©el                                ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    `);
});
